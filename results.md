![image](https://github.com/user-attachments/assets/2bc45260-f9ca-4643-91c5-37e64c60f697)

### **Висновки щодо ефективності алгоритмів сортування**

1. **Merge Sort:**
   - Час виконання **Merge Sort** залишається стабільним для всіх розмірів даних, демонструючи ефективність O(n log n).
   - Алгоритм добре підходить для великих масивів, але вимагає додаткової пам'яті для злиття підмасивів.

2. **Insertion Sort:**
   - Найшвидший для невеликих наборів даних (наприклад, 10 елементів).
   - Час виконання значно зростає для більших масивів через квадратичну складність O(n²).
   - На великих масивах (10,000 елементів) сортування неефективне, тому воно було пропущене.

3. **Timsort (sorted і sort):**
   - **Timsort** показав найкращі результати для всіх випадків, особливо на невеликих масивах.
   - Поєднання сортування злиттям і вставками робить його ефективним як для впорядкованих, так і для хаотичних масивів.
   - Алгоритм оптимізований для практичного використання, що підтверджується низьким часом виконання для великих масивів.

---

### **Загальний висновок**
- **Timsort** (вбудований у Python) є найбільш ефективним алгоритмом для реальних сценаріїв, забезпечуючи як швидкість, так і адаптивність.
- **Merge Sort** залишається надійним вибором для великих масивів, якщо потрібно стабільне сортування.
- **Insertion Sort** підходить лише для невеликих або частково впорядкованих даних.

Ці результати підтверджують доцільність використання вбудованих алгоритмів сортування Python у повсякденних задачах.
